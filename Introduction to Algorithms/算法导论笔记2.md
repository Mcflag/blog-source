title: "算法导论笔记2"
date: 2015-05-23 00:29:10
tags: [算法导论]
---

##摘要
对于算法的分析方法
<!--more-->


###2.2 分析算法

在大多数计算机中，将一个整数左移一位，等价于将该整数乘以2。于是左移k位等价于将该整数乘以2^k


###插入排序算法的分析

输入规模：输入规模大小会影响运行速度。
一个算法在特定输入上的运行时间是指执行的基本操作数或步数。

当插入排序的输入时最佳情况下，即输入已排好序的情况，运行时间为an+b，因此它是n的线性函数。
当输入是反向排序的情况下，每个循环都需要完全执行，运行时间为an^2+bn+c，是n的二次函数。


一般分析算法时需要考虑最坏情况，与平均情况。
如插入排序的平均情况，每次循环时，一半输入大，一半输入小，每次的运行时间是最坏情况的t/2，其实仍然是n的二次函数。
而且每个算法所针对的平均情况各异，有的并不明显，将会使用随机化算法和概率分析来研究算法的优劣。


增长量级
在实际分析算法中，经常抽象并忽略实际的运行代价。真正感兴趣的是运行时间的增长率或增长量级。
虽然并不确定高量级的算法一定慢于低量级的算法，但是对于足够大的输入，低量级比高量级算法运行的更快。
插入排序的量级可以写成θ(n^2),对于大量输入，比θ(n^3)的算法应该更快


###练习

####1. 用θ记号表示n^3/1000-100n^2-100n+3
实际上就是θ(n^3)。


####2. 选择算法。

>对于A数组中的n个数，首先找出A中最小元素与A[1]元素交换，然后找出A中次小元素与A[2]交换，依次进行。


伪代码

	
	int temp=0;
	int flag=0;
	for(int i=0;i<=n-2;i++){
		flag=i;
		for(int j=i+1;j<=n-1;j++){
			if(a[flag]>a[j]){
				flag=j;
			}
		}
		temp=a[i];
		a[i]=a[flag];
		a[flag]=temp;
	}
	

第一次循环，将从第2个开始的所有数中最小的放到第1个位置。
对于第j次循环，将从j+1开始到n的数中最小的放到第j个位置，在j之前的数一定比a[j]小。
因为对于执行第n-1次循环时，如果a[n]&lt;a[n-1]时，交换两个数，那么第n个数必定是最大的数，也就没必要对最后一个元素执行循环。
最好的情况输入已经排序，除了不需执行交换外赋值外，两层循环仍然需要执行，因此运行时间是θ(n^2)，
最坏的情况输入反向排序，运行时间也是θ(n^2)。


####3. 线性查找问题

> 要查找的元素等可能的为数组中任意元素，平均需要检查序列的多少元素，最坏的情况如何。

平均需要查找n/2的元素，最坏的情况需要查找全部元素。但是实际循环只有一层，不论如何运行时间为θ(n)。

####4. 如何修改几乎任意算法来使之具有良好的最好情况运行时间。

可以修改算法使之符合某些特定情况，或者已经进行过预先的处理，并且可以尽量减少循环的嵌套，来减少针对最好情况的运行时间。
但是这种针对最好情况的运行时间并不能作为算法优劣的主要考量。